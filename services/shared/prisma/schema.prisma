// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==============================
// ðŸŸ¢ USER & AUTH
// ==============================

model User {
  id                     String          @id @default(cuid())
  email                  String?         @unique
  provider               String
  providerId             String          @unique
  username               String?         @unique
  displayName            String?
  lastUsernameChange     DateTime?
  lastDisplayNameChange  DateTime?
  passwordHash           String?         
  avatarUrl              String?
  avatarColor            String?
  bio                    String?
  isPrivate              Boolean         @default(false)
  role                   Role            @default(USER)
  createdAt              DateTime        @default(now())
  updatedAt              DateTime        @updatedAt
  
  // Relations
  Event                  Event[]
  Participant            Participant[]
  sentFriendRequests     FriendRequest[] @relation("FromUser")
  receivedFriendRequests FriendRequest[] @relation("ToUser")
  posts                  Post[]          @relation("UserPosts")
  comments               Comment[]       @relation("UserComments")
  likes                  Like[]          @relation("UserLikes")
  conversationsAsA       Conversation[]  @relation("ConvoUserA")
  conversationsAsB       Conversation[]  @relation("ConvoUserB")
  conversationParticipants ConversationParticipant[]  // Soft-delete per user
  sentMessages           Message[]       @relation("SentMessages")
  preference             UserPreference?
  notifications          Notification[]

  // Gamification (back-relations sans nom explicite)
  userBadges UserBadge[]
  streak     Streak?

  followedBy Follow[] @relation("UserFollowedBy")
  following  Follow[] @relation("UserFollowing")
  
  refreshTokens RefreshToken[]

  // Follow Requests (private profiles)
  sentFollowRequests     FollowRequest[] @relation("FollowRequestsSent")
  receivedFollowRequests FollowRequest[] @relation("FollowRequestsReceived")
}

model Follow {
  id          String   @id @default(cuid())
  followerId  String
  followingId String
  createdAt   DateTime @default(now())

  follower  User @relation("UserFollowing", fields: [followerId], references: [id], onDelete: Cascade)
  following User @relation("UserFollowedBy", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
}

enum FollowRequestStatus {
  PENDING
  ACCEPTED
  REJECTED
}

model FollowRequest {
  id          String              @id @default(cuid())
  requesterId String
  targetId    String
  status      FollowRequestStatus @default(PENDING)
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt

  requester User @relation("FollowRequestsSent", fields: [requesterId], references: [id], onDelete: Cascade)
  target    User @relation("FollowRequestsReceived", fields: [targetId], references: [id], onDelete: Cascade)

  @@unique([requesterId, targetId])
  @@index([targetId, status])
}

// ==============================
// ðŸ—“ï¸ EVENTS
// ==============================

// --- Enums utiles ---
enum ParticipantRole {
  HOST
  GUEST
}

enum ParticipantStatus {
  INVITED
  GOING
  DECLINED
}

enum RecurrenceType {
  NONE
  DAILY
  WEEKLY
  MONTHLY
  YEARLY
}

// --- ModÃ¨le Event ---
model Event {
  id           String    @id @default(cuid())
  title        String
  description  String?
  startAt      DateTime
  endAt        DateTime?
  isPrivate    Boolean   @default(true)
  coverMediaId String?   @unique
  coverMedia   Media?    @relation("EventCover", fields: [coverMediaId], references: [id])
  medias       Media[]   @relation("EventMedias")

  // Theme support
  themeId      String?
  colorHex     String?

  // Location support
  location     String?

  // Recurrence support
  recurrenceType    RecurrenceType  @default(NONE)
  recurrenceEndAt   DateTime?       // When recurrence stops generating
  recurrenceGroupId String?         // Links recurring instances together

  ownerId String
  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Cascade)

  participants Participant[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  posts Post[] @relation("EventPosts")

  // Back-relation: all linked external events that map to this Event
  linkedExternalEvents LinkedEvent[] @relation("EventLinkedImports")

  visibility    Visibility     @default(PRIVATE)
  shareCode     String?        @unique
  notifications Notification[]

  @@index([ownerId])
  @@index([startAt])
  @@index([recurrenceGroupId])
}

// ==============================
// ðŸ‘¥ SOCIAL & POSTS
// ==============================

// --- ModÃ¨le Participant ---
model Participant {
  id String @id @default(cuid())

  eventId String
  event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  role   ParticipantRole   @default(GUEST)
  status ParticipantStatus @default(INVITED)

  createdAt DateTime @default(now())

  @@unique([eventId, userId]) // un utilisateur ne peut participer quâ€™une fois au mÃªme event
  @@index([userId])
}

enum FriendRequestStatus {
  PENDING
  ACCEPTED
  DECLINED
}

model FriendRequest {
  id         String              @id @default(cuid())
  fromUserId String
  toUserId   String
  status     FriendRequestStatus @default(PENDING)
  createdAt  DateTime            @default(now())
  decidedAt  DateTime?

  fromUser User @relation("FromUser", fields: [fromUserId], references: [id], onDelete: Cascade)
  toUser   User @relation("ToUser", fields: [toUserId], references: [id], onDelete: Cascade)

  @@unique([fromUserId, toUserId])
  @@index([toUserId, status])
  @@index([fromUserId, status])
}

model Post {
  id       String  @id @default(cuid())
  content  String
  authorId String
  author   User    @relation("UserPosts", fields: [authorId], references: [id])
  eventId  String?
  event    Event?  @relation("EventPosts", fields: [eventId], references: [id])

  likes    Like[]
  comments Comment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([authorId, createdAt(sort: Desc)])
  @@index([eventId, createdAt(sort: Desc)])
  @@index([createdAt, id])
}

model Comment {
  id        String   @id @default(cuid())
  postId    String
  post      Post     @relation(fields: [postId], references: [id])
  authorId  String
  author    User     @relation("UserComments", fields: [authorId], references: [id])
  content   String
  createdAt DateTime @default(now())

  @@index([postId, createdAt(sort: Desc)])
}

model Like {
  id        String   @id @default(cuid())
  postId    String
  post      Post     @relation(fields: [postId], references: [id])
  userId    String
  user      User     @relation("UserLikes", fields: [userId], references: [id])
  createdAt DateTime @default(now())

  @@unique([postId, userId])
}

// ==============================
// ðŸ“¸ MEDIA
// ==============================

model Media {
  id      String  @id @default(cuid())
  ownerId String
  eventId String?
  event   Event?  @relation("EventMedias", fields: [eventId], references: [id])

  coverOf Event? @relation("EventCover")

  kind         MediaKind
  bucket       String
  objectKey    String    @unique
  mimeType     String
  sizeBytes    Int
  width        Int?
  height       Int?
  durationSec  Int?
  thumbnailKey String?
  createdAt    DateTime  @default(now())
}

enum MediaKind {
  IMAGE
  VIDEO
}

// ==============================
// ðŸ’¬ MESSAGING
// ==============================

// Conversation status for message request feature
enum ConversationStatus {
  NORMAL    // Regular conversation (public profile or following)
  REQUEST   // Message request (private profile, not following)
  REJECTED  // Request was rejected by receiver
}

// --- Messagerie 1-to-1 (MVP) ---

model Conversation {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Paire d'utilisateurs (1-to-1). âš ï¸ Toujours trier les IDs (min -> max) cÃ´tÃ© serveur avant crÃ©ation.
  userAId String
  userBId String

  // Message request status
  status             ConversationStatus @default(NORMAL)
  
  // Request tracking (for private profile requests)
  requestSenderId    String?           // Who sent the first message (A)
  requestReceiverId  String?           // Who received the request (B - private profile)
  requestCreatedAt   DateTime?         // When REQUEST was created
  requestAcceptedAt  DateTime?         // When accepted
  requestRejectedAt  DateTime?         // When rejected
  
  // Legacy field (kept for compatibility)
  initiatedByUserId  String?           // Same as requestSenderId

  // Last message info for quick access
  lastMessageAt      DateTime?         // When last message was sent
  lastMessagePreview String?           // Preview of last message content

  userA        User      @relation("ConvoUserA", fields: [userAId], references: [id])
  userB        User      @relation("ConvoUserB", fields: [userBId], references: [id])
  messages     Message[]
  participants ConversationParticipant[]  // Per-user soft-delete tracking

  @@unique([userAId, userBId], name: "unique_pair")
  @@index([updatedAt])
  @@index([status])
  @@index([lastMessageAt])
  @@index([requestReceiverId])
}

// Per-user conversation state (supports soft-delete per participant)
model ConversationParticipant {
  id             String    @id @default(cuid())
  conversationId String
  userId         String
  lastDeletedAt  DateTime? // When user "deleted" (hid) this conversation
  createdAt      DateTime  @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@index([userId])
}

model Message {
  id             String      @id @default(cuid())
  conversationId String
  senderId       String
  content        String?     // Nullable if media only
  type           MessageType @default(TEXT)
  mediaUrl       String?
  duration       Int?        @default(0) // Duration in milliseconds
  read           Boolean     @default(false)
  delivered      Boolean     @default(false)
  
  replyToId      String?
  replyTo        Message?    @relation("ReplyTo", fields: [replyToId], references: [id])
  replies        Message[]   @relation("ReplyTo")

  editedAt       DateTime?   // Null if never edited
  deletedAt      DateTime?   // Soft delete timestamp
  
  createdAt      DateTime    @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation("SentMessages", fields: [senderId], references: [id])
  reactions    MessageReaction[]

  @@index([conversationId, createdAt])
}

model MessageReaction {
  id        String   @id @default(cuid())
  messageId String
  userId    String
  emoji     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId]) // 1 reaction per user per message
  @@index([messageId])
}

enum MessageType {
  TEXT
  IMAGE
  AUDIO
}

enum CalendarProvider {
  GOOGLE
  ICS
}

enum CalendarStatus {
  CONNECTED
  DISCONNECTED
}

// ==============================
// ðŸ“… LINKED CALENDARS
// ==============================

model LinkedCalendar {
  id          String           @id @default(cuid())
  userId      String
  provider    CalendarProvider
  displayName String?
  email       String?
  url         String? // pour ICS
  timezone    String? // ex: Europe/Paris
  status      CalendarStatus   @default(CONNECTED)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  events LinkedEvent[]

  @@index([userId])
}

model LinkedEvent {
  id               String   @id @default(cuid())
  linkedCalendarId String
  externalId       String // UID ICS ou id Google
  title            String
  description      String?
  start            DateTime
  endAt            DateTime // <-- corrigÃ©
  locationName     String?
  lat              Float?
  lng              Float?
  sourceUID        String? // iCal UID brut
  hash             String? // pour dÃ©dup rapide

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Lien optionnel vers un Event Lify (si converti ou dÃ©doublonnÃ©)
  lifyEventId String?
  lifyEvent   Event?  @relation("EventLinkedImports", fields: [lifyEventId], references: [id], onDelete: SetNull)

  calendar LinkedCalendar @relation(fields: [linkedCalendarId], references: [id])

  @@unique([linkedCalendarId, externalId])
  @@index([start, endAt])
}

// ==============================
// ðŸ”” PREFERENCES & NOTIFICATIONS
// ==============================

enum Visibility {
  PRIVATE
  FRIENDS
  LINK
  PUBLIC
}

model UserPreference {
  userId                 String     @id
  notificationOptIn      Boolean    @default(true)
  defaultEventVisibility Visibility @default(PRIVATE)
  createdAt              DateTime   @default(now())
  updatedAt              DateTime   @updatedAt

  user User @relation(fields: [userId], references: [id])
}

enum NotificationType {
  INVITE
  REMINDER
  GENERIC
}

model Notification {
  id        String           @id @default(cuid())
  userId    String
  type      NotificationType
  title     String
  message   String?
  eventId   String?
  read      Boolean          @default(false)
  createdAt DateTime         @default(now())

  user  User   @relation(fields: [userId], references: [id])
  event Event? @relation(fields: [eventId], references: [id])

  @@index([userId, read, createdAt])
}

// ==============================
// ðŸŽ® GAMIFICATION
// ==============================

// --- Gamification ---

enum BadgeType {
  FIRST_EVENT // 1er Ã©vÃ©nement crÃ©Ã©
  FIVE_SHARES // 5 partages envoyÃ©s
  THREE_ACTIVE_WEEKS // 3 semaines actives dâ€™affilÃ©e
  ONBOARDING_COMPLETE // Onboarding terminÃ© (tutoriel + permissions)
}

model Badge {
  id          String    @id @default(cuid())
  type        BadgeType @unique
  name        String
  description String
  icon        String? // URL ou clÃ© dâ€™asset
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  userBadges UserBadge[]
}

model UserBadge {
  id         String   @id @default(cuid())
  userId     String
  badgeId    String
  unlockedAt DateTime @default(now())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  badge Badge @relation(fields: [badgeId], references: [id], onDelete: Cascade)

  @@unique([userId, badgeId])
}

model Streak {
  id             String    @id @default(cuid())
  userId         String    @unique
  currentStreak  Int       @default(0) // jours consÃ©cutifs
  longestStreak  Int       @default(0)
  lastActiveDate DateTime? // derniÃ¨re activitÃ© comptabilisable (Ã©vÃ©nement crÃ©Ã©, partage, etc.)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

enum Role {
  USER
  ADMIN
  DEVELOPER
}

model RefreshToken {
  id        String   @id @default(cuid())
  tokenHash String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  revoked   Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
}
